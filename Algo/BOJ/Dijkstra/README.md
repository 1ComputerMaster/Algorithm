# 1 Dijkstra

**최단 경로 탐색 알고리즘**

핵심 개념 : 하나의 최단 거리를 구할 때 까지 그 이전까지 구했던 최단 거리 정보를 다시 사용한다.

## 순서

- 1. 출발 노드를 선정한다. (PS 문제에서는 0 번째로 자기 자신을 탐색하므로 거리도 0으로 시작하면 된다.)

- 2. 출발 노들르 기준으로 각 노드의 최소 비용을 저장한다.(minEdge 배열로 관리하기)

- 3. 방문하지 않은 노드 중에서 가장 비용이 작은 노드를 선정한다 (Priority Queue를 이용한다.)

- 4. 가장 비용이 작은 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용을 다시 갱신한다.

![image](https://user-images.githubusercontent.com/87481266/147853179-b588615f-7b8c-45db-875a-3a4ac6e2cfc6.png)

이 그래프의 거리를 지금 당장 나타낸 행렬이다.
특정 행에서 열로 가는 행렬이다.

0	2	5	1	무한	무한
2	0	3	2	무한	무한
5	3	0	3	1	5
1	2	3	0	1	무한
무한	무한	5
1	0	2
무한	무한	5	무한	2	0

![image](https://user-images.githubusercontent.com/87481266/147853219-2b773517-7e8e-465b-b3a5-8606d24fca2b.png)

minEdge의 상태

노드 1을 선택하였고 이때 그와 연결된 거리들을 다 업데이트 시켜준다.

**0**	2	5	1	무한	무한

4번 노드가 선택 되었다.

![image](https://user-images.githubusercontent.com/87481266/147853237-1580fdc9-27e9-4e33-b1e4-74158387589a.png)

여기서 1 -> 노드 4를 거쳐서 노드3을 가는 비용이 더 최소 이므로 업데이트
그리고 1 -> 4 -> 5로 가면 거리가 2로 업데이트

**0**	2	4	**1**	2	무한

이후 방문하지 않은 노드 중에서 비용이 가장 적은 노드로 간다. 2번 노드

![image](https://user-images.githubusercontent.com/87481266/147853314-36595953-a7cf-4346-9395-1af65cc57c08.png)


**0**	**2**	4	**1**	2	무한

갱신 되지 않았음

![image](https://user-images.githubusercontent.com/87481266/147853326-7be1af85-3950-4ffa-8f59-b72a83a44d33.png)

5를 거쳐서 3을 가는 경우가 비용이 3이므로 기존의 4보다 저렴하다 업데이트

5를 거쳐서 6을 가는 경우가 생기므로 4로 업데이트

**0**	**2**	3	**1**	**2**	4

![image](https://user-images.githubusercontent.com/87481266/147853359-c86463db-5d2f-412e-8979-a286a2b414ce.png)

반복

**0**	**2**	**3**	**1**	**2**	4

![image](https://user-images.githubusercontent.com/87481266/147853371-794e7071-4491-4c22-b5f5-3f3f8321b66c.png)


**0**	**2**	**3**	**1**	**2**	**4**
