# Dijkstra
**최단 거리 알고리즘**으로 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단거리 정보를 그대로 사용하므로 다이나믹 프로그래밍 문제 유형으로 보기도 합니다.

# 예시
```
     (2)
   1 ------ 2
   |        | \
(3)|     (3)|  \ (6)
   |        |   3
   4 ------ 5
       (1)    

```
## 초기 상태

노드:      1     2     3     4     5

거리:      0    ∞    ∞    ∞    ∞

방문:      T     F     F     F     F


## Step 1 : 노드 1번 방문

- 노드 1에서 인접한 노드들(2, 4)의 거리를 업데이트

노드:      1     2     3     4     5

거리:      0    **2**    ∞    **3**    ∞

방문:      F     F     F     F     F

## Step 2 : 노드 2번 방문

- 노드 2에서 연결된 노드(3, 5)의 거리를 업데이트

노드:      1     2     3     4     5

거리:      0    2    **5**    3    **8**

방문:      T     T     F     F     F

## Step 3 : 노드 4번 방문

노드 4에서 연결된 노드(5)의 거리를 업데이트합니다.

노드:      1     2     3     4     5

거리:      0    2    5    3    **4**

방문:      T     T     F     T     F

## Step 4 : 노드 5번 방문

- 5번은 방문 했지만 이미 다 업데이트가 된 것들이 최소 거리로 업데이트가 되어 있습니다.

노드:      1     2     3     4     5

거리:      0    2    5    3    4

방문:      T     T     F     T     T

## Step 5 : 노드 3번 방문

- 끝

노드:      1     2     3     4     5

거리:      0    2    5    3    4

방문:      T     T     T     T     T


## 설명

1. 출발 노드를 설정합니다.
2. 출발 노드를 기준으로 각 노드의 최소비용 결정
3. 이후 거칠 노드는 인접한 노드 중 Compare 함수를 구축하지 않았다면 그대로 나온 값을 사용
4. 위 과정 반복